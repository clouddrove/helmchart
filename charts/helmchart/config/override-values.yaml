replicaCount: 1

image:
  repository: nginx
  pullPolicy: IfNotPresent
  tag: "latest"
  digest: "sha256:09369da6b10306312cd908661320086bf87fbae1b6b0c49a1f50ba531fef2eab"

secret:
  enabled: true
  secrets:
    SECRET_KEY: "secret"

configmap:
  enabled: true
  configs:
    CONFIG_KEY: "configmap"

imagePullSecrets: [] 

commands:
  - /bin/sh
  - -c
  - echo "Hello, from CloudDrove!"; nginx -g 'daemon off;'

nameOverride: "" 

fullnameOverride: "" 

pdbMinAvailable: 30% 

serviceAccount:
  enabled: true  
  annotations: {}       
  name: ""
  automountServiceAccountToken: false 

podAnnotations: {} 

podSecurityContext:
  runAsUser: 0
  runAsGroup: 0
  fsGroup: 0
  seccompProfile:
    type: RuntimeDefault

securityContext:
  capabilities:
    add: ["NET_ADMIN", "SYS_TIME"]
  readOnlyRootFilesystem: false
  allowPrivilegeEscalation: false
  runAsGroup: 3000
  fsGroup: 2000

# volume for deployment 
volume:
  enabled: false 
  mountPath: ""
  hostPath: ""

service: 
  enabled: true
  name: http2
  type: NodePort 
  port: 80  
  containerPort: 80
  targetPort: http

istio:
  enabled: false
  virtualService:
    enabled: false
    hosts: 
      - test.example.com
      - test-2.example.com
  gateway:
    names: 
      - "istio-system/istio-gateway"

ingress:    
  enabled: false 
  className: "alb"
  annotations:
    alb.ingress.kubernetes.io/group.name: ingress
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}]'
  hosts:                        
    - host: chart-example.local
      paths:
        - path: /*
          pathType: ImplementationSpecific
  tls: []

resource:
  enabled: true
resources: 
  limits:
    cpu: 200m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

autoscaling:      
  enabled: true 
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80

poddisruptionbudget:
  enabled: false
  minAvailable: 30%

nodeSelector:
  kubernetes.io/os: linux

tolerations:
  - key: "clouddrove"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"

affinity:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
      - matchExpressions:
        - key: "kubernetes.io/os"
          operator: In
          values:
          - "linux" 

cronJob: 
  enabled: false
  schedule: ""
  startingDeadlineSeconds: 3600
  concurrencyPolicy: Forbid
  failedJobsHistoryLimit: 3
  resources: {}
  image:
    repository: nginx
    pullPolicy: IfNotPresent
    tag: "1.16.0" 
  secret:
    enabled: false
  configmap:
    enabled: false

metrics:
  enabled: false   
  portName: "prometheus" 
  port: 3001     
  targetPort: 3001 


storageClass:
  create: false
  existingClaim: ""
  # storageClassName: "mystorageclass"
  
  aws: false
  fileSystemId: "fs-abcd1234xyz"
  #accessPointId: "fsap-abcd1234xyz"
  azure: false
  
  gcp: false

  provisioner: "k8s.io/minikube-hostpath"
  #provisioner: "kubernetes.io/aws-ebs"
  #provisioner: efs.csi.aws.com

  allowVolumeExpansion: false
  volumeBindingMode: Immediate

  persistence:
    enabled: false
    accessMode: ReadWriteOnce
    size: 512Mi
    persistentVolumeReclaimPolicy: ""
    existingClaim: null # Name of an existing PVC to use

ClusterIP:
  enabled: false   # üëà Controls if the Service should be headless (clusterIP: None)

deploymentStrategy:
  type: Recreate

statefulset:
  enabled: true



# rBAC settings
rbac:
  create: true

  role:
    enabled: true
    name: myapp-role
    rules:
    # Manage workloads (Deployments, StatefulSets, DaemonSets)
    - apiGroups: ["apps"]
      resources: ["deployments", "statefulsets", "daemonsets"]
      verbs: ["get", "list", "watch", "create", "update", "patch"]

    # Manage Services and ConfigMaps
    - apiGroups: [""]
      resources: ["services", "configmaps"]
      verbs: ["get", "list", "watch", "create", "update", "patch"]

    # Read-only access to Secrets (no create/update/delete)
    - apiGroups: [""]
      resources: ["secrets"]
      verbs: ["get", "list"]

    # Read and stream pod logs (subresource access)
    - apiGroups: [""]
      resources: ["pods", "pods/log"]
      verbs: ["get", "list", "watch"]

    # Patch Events (so controllers can annotate or update them)
    - apiGroups: [""]
      resources: ["events"]
      verbs: ["get", "list", "patch", "watch"]

    # Manage RoleBindings (optional: allows automation tools to bind users dynamically)
    - apiGroups: ["rbac.authorization.k8s.io"]
      resources: ["rolebindings"]
      verbs: ["get", "list", "create", "update"]


  roleBinding:
    enabled: true
    name: myapp-rolebinding
    users:
      enabled: true 
      list:
        - dev-user1
        - dev-user2
    groups:
      enabled: true 
      list:
        - devops-team

  clusterRole:
    enabled: true 
    name: myapp-clusterrole
    rules:
      - apiGroups: ["apps"]
        resources: ["deployments"]
        verbs: ["get", "list"]

  clusterRoleBinding:
    enabled: true 
    name: myapp-clusterrolebinding
    users:
      enabled: true 
      list:
        - admin-user1
        - admin-user2
    groups:
      enabled: true 
      list: 
        - admin-team 



## demonset settings 
daemonset:
  enabled: true

  # Options: logging | networking | monitoring | security
  scenario: logging

  imagePullSecrets: []

  logging:
    image: fluent/fluentd:v1.16
    resources:
      limits:
        cpu: 200m
        memory: 256Mi
      requests:
        cpu: 100m
        memory: 128Mi
    volumeMounts:
      - name: varlog
        mountPath: /var/log
    volumes: 
      - name: varlog
        hostPath:
          path: /var/log

  # networking:
  #   image: cilium/cilium:v1.16
  #   args:
  #     - "--enable-ipv4=true"
  #     - "--enable-ipv6=false" 

  # monitoring:
  #   image: prom/node-exporter:v1.8.1

  # security:
  #   image: falcosecurity/falco:latest



## ingressClass settings
ingressClass:
  enabled: false
  name: my-ingress-class
  # scenario options: nginx | alb | gce | custom
  scenario: nginx

  # Custom controller name (only used when scenario = custom)
  customController: "example.com/custom-ingress-controller"
    # controller: k8s.io/ingress-nginx
    # controller: ingress.k8s.aws/alb
    # controller: k8s.io/ingress-gce
  # Example of default annotations (can override per scenario)
  annotations: {}
    # ingressclass.kubernetes.io/is-default-class: "true"
    # ingressclass.kubernetes.io/controller: "k8s.io/ingress-nginx"
    # ingressclass.kubernetes.io/controller: ingress.k8s.aws/alb
    # ingressclass.kubernetes.io/controller: k8s.io/ingress-gce
    # ingressclass.kubernetes.io/controller: example.com/custom-ingress-controller


## verticalPodAutoscaler settings
vpa:
  enabled: true 
  targetKind: Deployment
  containerName: "*"

  # Scenario 1Ô∏è‚É£ ‚Äî Automatic updates (default)
  updateMode: "Auto"
  controlledResources: ["cpu", "memory"]
  minAllowed:
    cpu: 100m
    memory: 128Mi
  maxAllowed:
    cpu: 2
    memory: 2Gi
  controlledValues: "RequestsAndLimits"

  # Scenario 2Ô∏è‚É£ ‚Äî Recommendation only (no live updates)
  # updateMode: "Off"
  # controlledValues: "RequestsOnly"

  # Scenario 3Ô∏è‚É£ ‚Äî Update on Pod restart only
  # updateMode: "Initial"
  # controlledValues: "RequestsAndLimits"

  # Scenario 4Ô∏è‚É£ ‚Äî Strict capped resources (for staging)
  # updateMode: "Auto"
  # minAllowed:
  #   cpu: 250m
  #   memory: 256Mi
  # maxAllowed:
  #   cpu: 500m
  #   memory: 512Mi
  # controlledValues: "RequestsAndLimits"

  # Scenario 5Ô∏è‚É£ ‚Äî Recommendations only for monitoring tools
  # updateMode: "Off"
  # controlledResources: ["cpu", "memory"]
  # controlledValues: "RequestsOnly"



## NetworkPolicy settings
networkPolicy:
  enabled: true 

  # Optional: explicitly define policy types
  policyTypes:
    - Ingress
    - Egress

  # ‚úÖ Scenario 1: Allow ingress only from same app within namespace
  ingress:
    - fromPods:
        app: myapp
      ports:
        - protocol: TCP
          port: 80

  # ‚úÖ Scenario 2: Allow ingress from another namespace (e.g., monitoring)
    # - fromNamespaces:
    #     name: monitoring
    #   ports:
    #     - protocol: TCP
    #       port: 8080

  # ‚úÖ Scenario 3: Allow ingress from external CIDR range
    # - fromCIDRs:
    #     cidr: 10.0.0.0/8
    #     except:
    #       - 10.10.0.0/16
    #   ports:
    #     - protocol: TCP
    #       port: 443

  # ‚úÖ Scenario 4: Allow egress to all (for updates)
  # egress:
  #   - toCIDRs:
  #       cidr: 0.0.0.0/0
  #     ports:
  #       - protocol: TCP
  #         port: 443

  # ‚úÖ Scenario 5: Allow egress to internal DB service
    # - toPods:
    #     app: postgres
    #   ports:
    #     - protocol: TCP
    #       port: 5432
